        .ABSOLUTE
	.PROC   UBOOT
        .TITLE  "UBOOT  - SECOND-LEVEL BOOTSTRAP FOR UCSD OPERATING SYSTEM"    

	.INCLUDE  BIOS_CFG.TEXT
        .INCLUDE *:ASMINC.TEXT

	DEF_CH			; DEFINE SYMBOLS FOR ASCII CHARACTERS

;  VERSION F1

        .PAGE
;*        ASSEMBLY PARAMETERS AND CONFIGURATION INFO
;
;
DDTBOOT .EQU    0		; ASSEMBLE BOOT FOR DDT
IDE	.EQU	1		; ASSEMBLE FOR IDE DISKS
DEBUG	.EQU	0		; DISPLAY PROGRESS MESSAGES FOR DEBUGGING

	.IF     DDTBOOT=0
INTRPORG .EQU   2000H           ; INTERPRETER ORIGIN
INTENTRY .EQU   INTRPORG+100H   ; INTERPRETER ENTRY POINT
	.ELSE
INTRPORG .EQU   0ED80H          ; DDT ORIGIN
INTENTRY .EQU   INTRPORG+1      ; DDT INITIALIZATION ENTRY POINT
DDTBTSP .EQU    INTRPORG-2      ; TOP OF NEW STACK
	.ENDC

	.IF	IDE=0
DSKFMT  .EQU    MAPOPT+RQSIZ5+V_DRQDDN   ; "OPTIMIZED" DISK FORMAT
	.ELSE
DSKFMT  .EQU    0H   		; IDE DISK FORMAT
	.ENDC


;*        INTERNAL SYMBOLS
;
;
DIRECT  .EQU    INTRPORG        ; THE DIRECTORY BUFFER IS OVERLAID BY THE INTERPRETER
FBLKSIZE .EQU    512.           ; STANDARD DISK BLOCK LENGTH
;
;  DEFINITIONS FOR UCSD DISK VOLUME DIRECTORIES.
;
DIRBLK  .EQU    2               ; UCSD BLOCK NUMBER OF DIRECTORY
NDIRBLK .EQU    4               ; NUMBER OF BLOCKS IN DIRECTORY
LE_DIR  .EQU    26.             ; BYTES PER DIRECTORY ENTRY
C_FIRST .EQU    0               ; FIRST BLOCK ADR WITHIN ENTRY
C_LAST  .EQU    2               ; LAST BLOCK ADR WITHIN ENTRY
C_NAME  .EQU    6               ; FILE TITLE WITHIN ENTRY
MAXDIR  .EQU    77.             ; NUMBER OF POSSIBLE DIRECTORY ENTRIES

	.IF	DEBUG
	.MACRO PROGRESS
	LD	C,%1
	CALL	SHOWPROG
	.ENDM
	.ELSE
	.MACRO PROGRESS
	.ENDM
	.ENDC

        .PAGE
        
	.ORG    BOOTADR
        JP      BEGIN           ; SKIP OVER VARIABLE STORAGE

;*	  CONSTANTS AND VARIABLES
;
;  THESE MUST BE IN THE FIRST 512 BYTES OF THE BOOTSTRAP
;  BECAUSE SOME OF THEM ARE REFERENCED BEFORE WE READ
;  IN THE SECOND BOOTSTRAP SECTOR.
;


;*        DISK REQUEST BLOCK
;
;
REQBLK
        .BLOCK  1               ; SPACE FOR UNIT NUMBER
        .BLOCK  3               ; ABSOLUTE ADDRESS
        .BYTE   DSKFMT          ; DISK FORMAT
        .BYTE   0               ; FLAGS
        .BLOCK  1               ; S0 ADDRESS
        .BYTE   0               ; EXPANSION BYTE
        .BLOCK  2               ; MEMORY ADDRESS
        .BYTE   1               ; SECTOR COUNT


;*        VARIABLES
;
;
SECCNT  .BLOCK  1               ; SECTOR COUNT DURING READ
MEMTOP  .BLOCK  2               ; POINTER TO TOP OF AVAILABLE MEMORY

;  WELL-KNOWN NAME OF THE INTERPRETER.
	.IF     DDTBOOT=0
ITITLE  .ASCII  "SYSTEM.MICRO"  ; INTERPRETER TITLE
	.ELSE
ITITLE  .ASCII  "DDT.BOOTCODE"  ; DDT TITLE
	.ENDC

L_INTNAM .EQU   $-ITITLE        ; LENGTH OF INTERPRETER TITLE

;
;  THIS ERROR MESSAGE MUST IMMEDIATELY FOLLOW THE NAME OF THE
;  INTERPRETER, SO THAT NAME CAN BE CONCATENATED TO THE BEGINNING
;  OF THE MESSAGE.
;
NOSYSMSG .ASCII " IS NOT ON BOOTSTRAP DISK."
	.BYTE	CH_CR
	.BYTE	CH_LF
	.ASCII	"BOOTSTRAP ABORTED."
L_NSMSG .EQU	$-NOSYSMSG	; LENGTH OF MESSAGE

DERRMSG .BYTE	CH_CR
	.BYTE	CH_LF
	.ASCII "DISK ERROR!"
L_DEMSG .EQU	$-DERRMSG	; LENGTH OF MESSAGE

CRLF	.BYTE	CH_CR
	.BYTE	CH_LF
L_CRLF	.EQU	$-CRLF

        .PAGE
;*        BOOTSTRAP ENTRY CONDITIONS DEFINED BY MONITOR
;
;  B REGISTER CONTAINS THE NUMBER OF THE DISK UNIT
;         FROM WHICH THE BOOTSTRAP WAS READ.
;
;  C REGISTER CONTAINS THE ENTRY CODE:
;
;         0 - FAST BOOTSTRAP (MONITOR F COMMAND)
;         1 - STANDARD BOOTSTRAP (MONITOR B COMMAND)
;         FF - PATCHING MODE (MONITOR P COMMAND)
;
;  HL REGISTER CONTAINS THE ADDRESS OF THE HIGHEST
;  MEMORY LOCATION THAT IS AVAILABLE.
;
;  SP REGISTER EQUAL TO HL.
;
BEGIN
        LD      (MEMTOP),HL     ; STORE POINTER TO TOP OF AVAILABLE MEMORY
        LD      A,B             ; GET UNIT NUMBER PASSED BY BOOT
        LD      (REQBLK+C_DRQUNT),A ; STORE BOOT DISK UNIT NUMBER
	PROGRESS "A"

	.IF     DDTBOOT<>0
	LD      SP,DDTBTSP      ; MOVE STACK IF BOOTING DDT
	.ENDC
;
;  THE MONITOR READS A SINGLE 512-BYTE DISK SECTOR AS
;  THE BOOTSTRAP.  WE MAY BE BIGGER THAN THAT, SO WE
;  READ THE BLOCK AT LBA 1 AS OUR SECOND HALF.
;
        LD      DE,1       	; LBA OF OUR SECOND HALF
        LD      HL,1      	; BLOCK COUNT
        LD      BC,BOOTADR+FBLKSIZE; PLACE TO READ IT TO
        CALL    UCSDRD          ; READ SECOND HALF OF THIS BOOTSTRAP
;
;  NOW READ THE DISK DIRECTORY INTO MEMORY.
;
        PROGRESS "B"
	LD      DE,DIRBLK       ; DIRECTORY ADDRESS
        LD      HL,NDIRBLK      ; LENGTH OF DIRECTORY
        LD      BC,DIRECT       ; PLACE TO READ IT TO
        CALL    UCSDRD          ; READ DIRECTORY
;
;  SEARCH THE DIRECTORY FOR THE INTERPRETER
;
        LD      IX,DIRECT+LE_DIR ; SKIP OVER VOLUME ENTRY
        LD      B,MAXDIR         ; NUMBER OF ENTRIES TO SEARCH

ENTLOOP
        PUSH    BC              ; SAVE ENTRY COUNT
        PUSH    IX              ; SAVE ENTRY POINTER

 	.IF	DEBUG
	POP	HL		; COPY ENTRY POINTER TO HL
	PUSH	HL

	LD	BC,C_NAME	; ADVANCE TO THE NAME STRING
	ADD	HL,BC	

	LD	A,(HL)		; DISPLAY THE NEXT FILE NAME
	LD	C,A
	LD	B,0
	INC	HL
	MTRREQ	M_DSPTXT

	LD	HL,CRLF		; ADVANCE TO THE NEXT LINE
	LD	BC,L_CRLF
	MTRREQ	M_DSPTXT

	POP	IX		; RESTORE IX
	PUSH	IX		; AND PUT IT BACK ON STACK FOR NXTEND
	.ENDC

	LD      A,(IX+C_NAME)   ; GET BYTE COUNT OF NEXT TITLE
        CP      L_INTNAM        ; SEE IF MATCHES DESIRED TITLE
        JR      NZ,NXTENT       ; JUMP IF NO MATCH

        LD      IY,ITITLE       ; ADR OF INTERPRETER TITLE
        LD      B,A             ; MOVE LENGTH TO B

CHLOOP
        LD      A,(IX+C_NAME+1) ; GET NEXT CHARACTER
        CP      (IY+0)          ; COMPARE
        JR      NZ,NXTENT       ; JUMP IF NO MATCH

        INC     IX              ; BUMP POINTERS
        INC     IY
        DJNZ    CHLOOP          ; LOOP IF MORE CHARS TO GO

        JR      MATCH


;*
;  COME HERE IF THIS ENTRY DOES NOT MATCH WHAT WE ARE LOOKING FOR.
;
NXTENT
        POP     IX              ; RESTORE ENTRY POINTER
        POP     BC              ; RESTORE ENTRY COUNT

        LD      DE,LE_DIR       ; LENGTH OF DIRECTORY ENTRY
        ADD     IX,DE           ; BUMP POINTER

        DJNZ    ENTLOOP         ; LOOP IF MORE ENTRIES TO GO
;
;  WE DID NOT FIND THE INTERPETER IN THE DIRECTORY, SO PUT OUT AN ERROR MESSAGE
;  AND HANG.
;
	LD	HL,ITITLE	; DISPLAY ERROR MESSAGE WITH INTERP TITLE IN FRONT
	LD	BC,L_INTNAM+L_NSMSG
	MTRREQ	M_DSPTXT

$10     JR	$10             ; LOOP FOREVER



;*
;  COME HERE AFTER THE PROPER ENTRY HAS BEEN FOUND IN THE
;  DIRECTORY.  THE STACK STILL CONTAINS THE ENTRY POINTER
;  AND THE (NOW USELESS) ENTRY COUNT.
;
MATCH	
        POP     IX              ; RESTORE ENTRY POINTER
        POP     BC              ; TAKE COUNT OFF THE STACK
	PROGRESS "D"
;
;  COMPUTE THE SECTOR COUNT FOR READING IN THE INTERPRETER.
;
        LD      L,(IX+C_LAST)   ; GET LAST+1 BLOCK NUMBER
        LD      H,(IX+C_LAST+1)
        LD      E,(IX+C_FIRST)  ; GET FIRST BLOCK NUMBER
        LD      D,(IX+C_FIRST+1)
        AND     A             	; CLEAR C FLAG
        SBC     HL,DE           ; GET FILE SIZE IN BLOCKS

        LD      BC,INTRPORG     ; INTERPRETER ORIGIN
        CALL    UCSDRD          ; READ UCSD FILE

;
;  SET UP PARAMETERS FOR THE INTERPRETER, AND GO TO IT.
;
        PROGRESS "E"
	LD      HL,(MEMTOP)     ; FIRST AVAILABLE MEMORY WORD
        LD      SP,HL           ; PUT STACK AT TOP OF MEMORY
	LD      A,(REQBLK+C_DRQUNT) ; BOOTSTRAP UNIT NUMBER
        LD      B,A             ; MOVE TO B
        JP      INTENTRY        ; GO TO INTERPRETER BOOT
        .PAGE
;*        SUBROUTINE UCSDRD - READ UCSD FILE
;
;         ENTRY - L CONTAINS BLOCK COUNT
;                 DE CONTAINS BLOCK ADDRESS
;                 BC CONTAINS MEMORY ADDRESS
;
UCSDRD
        LD      A,L             ; STORE SECTOR COUNT
        LD      (SECCNT),A
        LD      (REQBLK+C_DRQADR),BC ; STORE MEMORY ADDRESS

	.IF	IDE
	LD	(REQBLK+C_DRQTRK),DE ; STORE BLOCK ADDRESS
	.ELSE
        EX      DE,HL           ; MOVE BLOCK ADR TO HL
        ADD     HL,HL           ; MULTIPLY BY 4
        ADD     HL,HL
        EX      DE,HL           ; MOVE BACK TO DE
        LD      HL,REQBLK       ; REQUEST BLOCK ADR
        MTRREQ  M_DSKADR        ; CONVERT DISK ADDRESS
	.ENDC

;
;  SECTOR READ LOOP.
;
SECLOOP
        LD      HL,REQBLK       ; READ ONE SECTOR
        MTRREQ  M_DSKRD
        AND     A
        JR      NZ,IOERROR      ; JUMP ON I/O ERROR

        LD      HL,(REQBLK+C_DRQADR) ; BUMP MEMORY ADDRESS
        LD      DE,FBLKSIZE
        ADD     HL,DE
        LD      (REQBLK+C_DRQADR),HL

        LD      HL,SECCNT       ; DECREMENT SECTOR COUNT
        DEC     (HL)
        JR      NZ,SECLOOP      ; LOOP IF MORE TO GO

        RET

;
;  REPORT A DISK ERROR AND HANG.
;
IOERROR	LD	HL,DERRMSG	; DISPLAY ERROR MESSAGE
	LD	BC,L_DEMSG
	MTRREQ	M_DSPTXT

$10	JR	$10

	.PAGE
;*        SUBROUTINE SHOWPROG - DISPLAY A PROGRESS INDICATOR
;
;  OUTPUT A SINGLE CHARACTER, FOLLOWED BY <CR><LF>.
;
;         ENTRY - PARAMETER IN C REGISTER.
;
;         EXIT - ALL REGISTERS PRESERVED.
;
	.IF	DEBUG
SHOWPROG
        PUSH    IX              ; SAVE ALL USER REGISTERS
        PUSH    IY
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    AF

        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER
	LD	C,CH_CR
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER
	LD	C,CH_LF
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER

        MTRREQ	M_KBCHAR	; WAIT FOR USER

        POP     AF              ; RESTORE USER REGISTERS
        POP     BC
        POP     DE
        POP     HL
        POP     IY
        POP     IX

	RET
	.PAGE

;*        SUBROUTINE HEXOUT - WRITE OUT ONE BYTE IN HEX
;
;  TRANSLATE THE PARAMETER BYTE INTO TWO HEXIDECIMAL
;  CHARACTERS, AND WRITE THEM TO THE USER.
;
;         ENTRY - PARAMETER IN A REGISTER.
;
;         EXIT - A REGISTER DESTROYED.
;                ALL OTHERS PRESERVED.
;

HEXOUT
        PUSH    AF              ; SAVE PARAMETER FOR LATER
        SRL     A               ; RIGHT-JUSTIFY TOP DIGIT
        SRL     A
        SRL     A
        SRL     A
        CP      10.             ; IS IT NUMERIC
        JR      C,HEXOUTA       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTA
        ADD     A,"0"           ; MAKE INTO  ASCII
        CALL    OUTPUTCH        ; WRITE TOP NIBBLE

        POP     AF              ; GET BACK NUMBER
        AND     0FH             ; SAVE LOW DIGIT
        CP      10.             ; IT IS NUMERIC
        JR      C,HEXOUTB       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTB
        ADD     A,"0"           ; MAKE INTO ASCII
        CALL    OUTPUTCH        ; WRITE OUT BOTTOM DIGIT

        RET     	        ; AND  RETURN TO CALLER
        .PAGE
;*        SUBROUTINE TXTOUT - WRITE TEXT BLOCK TO USER
;
;  TRANSFER A TEXT STRING TERMINATED BY AN ETX CHARACTER TO
;  THE USER.
;
;         ENTRY - ADDRESS OF FIRST CHARACTER OF STRING IN HL
;
;         EXIT - HL POINTS TO ETX CHARACTER.
;                A CONTAINS -CH.ETX-
;                ALL OTHER REGISTERS ARE PRESERVED.
;
TXTOUT
        LD      A,(HL)          ; GET NEXT CHARACTER IN TEXT
        CP      CH_ETX          ; IS IT END-OF-TEXT
        RET     Z               ; RETURN IF IT IS END-OF-TEXT

        CALL    OUTPUTCH        ; WRITE OUT CHARACTER
        INC     HL              ; BUMP TEXT POINTER
        JR      TXTOUT          ; AND LOOP FOR NEXT CHARACTER
        .PAGE
;*        SUBROUTINE OUTPUTCH
;
;  WRITE ONE CHARACTER FROM REGISTER A TO THE
;  DISPLAY.
;
;         ENTRY - CHARACTER IN A
;
;         EXIT - ALL REGISTERS PRESERVED
;
OUTPUTCH
        PUSH    IX              ; SAVE ALL USER REGISTERS
        PUSH    IY
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    AF

        LD      C,A             ; MOVE CHARACTER TO C REGISTER
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER

        POP     AF              ; RESTORE USER REGISTERS
        POP     BC
        POP     DE
        POP     HL
        POP     IY
        POP     IX

        RET
	.ENDC
	.PAGE
;
;  GENERATE ERROR IF WE ARE TOO BIG TO FIT INTO TWO DISK SECTORS.
;
	.ORG	BOOTADR+FBLKSIZE+FBLKSIZE
        .END

