        .TITLE  "BOOTSTP - SECOND-LEVEL BOOTSTRAP"
        .ABSOLUTE
        .PROC   BOOTSTP

	.INCLUDE  BIOS_CFG.TEXT
	.INCLUDE  *:ASMINC.TEXT

	DEF_CH

DEBUG	.EQU	TRUE


;       MODIFICATIONS:
;
;  03 JAN 16 - CREATED.

;  THIS VERSION HAS BEEN REWRITTEN FROM SCRATCH.  THERE
;  MUST HAVE BEEN A FUNCTIONALLY-EQUIVALENT VERSION THAT
;  I USED IN THE 1980'S, BUT I CAN'T FIND THE SOURCE.
;  SOME OF THIS CODE IS DERIVED FROM BOOT.TEXT IN
;  THE INTERPRETER SOURCE.
;
;  THE MONITOR READS A SINGLE 512-BYTE DISK SECTOR AS
;  THE BOOTSTRAP.  WE MAY BE BIGGER THAN THAT, SO WE
;  READ THE BLOCK AT LBA 1 AS OUR SECOND HALF.
;
;  IT APPEARS FROM A SYSTEM.MICRO ARCHIVED ON BITSAVERS.ORG
;  THAT THE FIRST 0X200 BYTES OF THE FILE GENERATED BY THE
;  ASSEMBLER HAVE BEEN REMOVED, SO THAT THE FIRST BYTE IN THE
;  FILE IS THE FIRST BYTE IN THE INTERPETER (THE OPERATION
;  DISPATCH TABLE).  THE ENTRY POINT IS AT A FIXED OFFSET
;  OF 0X100 BYTES FROM THE BEGINNING OF THE INTERPRETER.
;
;  ??  IT'S NOT CLEAR WHETHER THE INTERPRETERS THAT I
;  ??  BUILT MYSELF HAVE THEIR FIRST 512 BYTES REMOVED.
;  ??  THEREFORE, THIS BOOTSTRAP MAY EXPECT A DIFFERENT
;  ??  FILE FORMAT THAN THE ONE ON THE FLOPPY DISKS.

	.IF	DEBUG
	.MACRO PROGRESS
	LD	C,%1
	CALL	SHOWPROG
	.ENDM
	.ELSE
	.MACRO PROGRESS
	.ENDM
	.ENDC

        .PAGE
	.PAGE
;*	   DEFINITIONS
;
;  ??  DOES THIS ADDRESS HAVE TO BE FIXED?  CAN'T DISK-BASED DDT
;  ??  LOAD THE INTERPRETER AFTER ITSELF AND EVERYTHING
;  ??  WORKS?
INTERPORG .EQU	2000H		; LOADING ADDRESS FOR INTERPRETER

DIRBUF	.EQU	INTERPORG	; BUFFER FOR DISK DIRECTORY
FMTIDE	.EQU	0		; FORMAT CODE FOR IDE DRIVES

L_BGSEC .EQU	512.		; LENGTH OF A BIG DISK SECTOR

; FORMAT OF DISK DIRECTORY, FROM THE PASCAL TYPE DEFINITIONS.
DFIRSTBLK .EQU	0		; FIRST BLOCK # OF FILE
DLASTBLK .EQU	2		; BLOCK # JUST BEYOND END OF FILE
DTITLE	.EQU	6		;OFFSET OF TITLE IN AN ENTRY
DENTSZ	.EQU	1AH		;DIRECTORY ENTRY SIZE, BYTES

ENTRYPT	.EQU	100H		; OFFSET IN INTEPRETER OF ITS ENTRY POINT.

	.PAGE
;*        BOOTSTRAP ENTRY CONDITIONS
;
;  B REGISTER CONTAINS THE NUMBER OF THE DISK UNIT
;         FROM WHICH THE BOOTSTRAP WAS READ.
;
;  C REGISTER CONTAINS THE ENTRY CODE:
;
;         0 - FAST BOOTSTRAP (MONITOR F COMMAND)
;         1 - STANDARD BOOTSTRAP (MONITOR B COMMAND)
;         FF - PATCHING MODE (MONITOR P COMMAND)
;
;  HL REGISTER CONTAINS THE ADDRESS OF THE HIGHEST
;  MEMORY LOCATION THAT IS AVAILABLE.
;
;  SP REGISTER EQUAL TO HL.
;

	.ORG	BOOTADR
	JP	DOBOOT

	.PAGE
;*	  CONSTANTS AND VARIABLES
;
;  THESE MUST BE IN THE FIRST 512 BYTES OF THE BOOTSTRAP
;  BECAUSE SOME OF THEM MAY BE REFERENCED BEFORE WE READ
;  IN THE SECOND BOOTSTRAP SECTOR.
;
;  WELL-KNOWN NAME OF THE INTERPRETER.
SYSTLE	.BYTE	12.		;LENGTH BYTE OF STRING
	.ASCII	"SYSTEM.MICRO" ;CHARACTERS OF STRING
L_STLE	.EQU	$-SYSTLE

NOSYSMSG .BYTE	CH_CR
	.BYTE	CH_LF
	.ASCII "SYSTEM.MICRO IS NOT ON BOOTSTRAP DISK.  "
	.BYTE	CH_CR
	.BYTE	CH_LF
	.ASCII	"BOOTSTRAP ABORTED."
L_NSMSG .EQU	$-NOSYSMSG	; LENGTH OF MESSAGE

DERRMSG .BYTE	CH_CR
	.BYTE	CH_LF
	.ASCII "DISK ERROR!"
L_DEMSG .EQU	$-DERRMSG	; LENGTH OF MESSAGE

CRLF	.BYTE	CH_CR
	.BYTE	CH_LF
L_CRLF	.EQU	$-CRLF

MEMTOP	.BLOCK	2		; WORD POINTER TO TOP OF USABLE RA
RDCNT	.BLOCK	2		; SECTORS REMAINING TO READ
DENTP	.BLOCK	2		; POINTER TO DIRECTORY ENTRY

;*        DISK REQUEST BLOCK
;
;  INITIALIZED TO READ SECOND BLOCK OF BOOTSTRAP
;  INTO MEMORY.
DSKRQ	.BLOCK  1               ; SPACE FOR UNIT NUMBER
        .WORD   1         	; BLOCK #
        .BYTE   0       	; SECTOR ADDRESS UNUSED BY IDE
        .BYTE   FMTIDE 		; FORMAT CODE
        .BYTE   0               ; FLAGS
        .BLOCK	2		; UNUSED
        .WORD   BOOTADR+L_BGSEC ; ADDRESS OF 2ND SECTOR OF BOOT IN MEMORY
	.BLOCK	1		; UNUSED

;
;  SAVE PARAMETERS PASSED BY MONITOR.
;
DOBOOT	LD	(MEMTOP),HL	; REMEMBER THE TOP OF MEMORY
	LD	A,B
	LD	(DSKRQ+C_DRQUNT),A  ; BOOT UNIT NUMBER
	PROGRESS "A"
;
;  READ THE SECOND BLOCK OF THIS PROGRAM FROM DISK.
;  THE REQUEST BLOCK IS ALREADY INITIALIZED FOR THIS.
;
	LD	HL,DSKRQ	; READ ONE BLOCK
	MTRREQ	M_DSKRD
	AND	A
	JR	Z,RDDIR		; JUMP IF NO ERROR
;
;  REPORT A DISK ERROR AND LOOP FOREVER.
;
DSKERR	LD	HL,DERRMSG	; DISPLAY ERROR MESSAGE
	LD	BC,L_DEMSG
	MTRREQ	M_DSPTXT

$10	JR	$10		; HANG FOREVER

;
;  READ IN THE DISK'S DIRECTORY FROM ITS FIXED
;  LOCATION AND LENGTH.
;
RDDIR	PROGRESS "B"
	LD	HL,DIRBUF	;BUFFER FOR DIRECTORY
	LD	(DSKRQ+C_DRQADR),HL
	LD	HL,02H		;DIR STARTS AT BLOCK 2
	LD	(DSKRQ+C_DRQTRK),HL
	LD	HL,4		;LENGTH, 4 BLOCKS
	CALL	DSKRD		; READ MULTIPLE SECTORS

;
;	SEARCH DIR FOR THE INTERPRETER
;
	LD	HL,DIRBUF+DENTSZ ;SKIP OVER ENTRY 0, DISK NAME
	LD	(DENTP),HL
	LD	C,77.		; MAX ENTRIES IN A DIRECTORY

;		;(DENTP)=^DIR ENTRY, HL=^DIR.TITLE, DE=^SYSTITLE, C=COUNTER
$20	;OUTER, LOOP ON EACH DIR ENTRY
	PROGRESS "C"
	LD	DE,DTITLE	;INC HL TO .TITLE IN ENTRY
	ADD	HL,DE

	.IF	DEBUG
	PUSH	HL
	PUSH	BC
	LD	A,(HL)
	LD	C,A
	LD	B,0
	INC	HL
	MTRREQ	M_DSPTXT

	LD	HL,CRLF
	LD	BC,L_CRLF
	MTRREQ	M_DSPTXT

	POP	BC
	POP	HL
	.ENDC

	LD	DE,SYSTLE	;SET DE TO TITLE FOR COMPARISON
	LD	B,L_STLE	;COMP FOR LENGTH OF TITLE

$30	;INNER, LOOP ON CHARACTERS
	LD	A,(DE)
	CP	(HL)
	JP	NZ,$40

	INC	DE
	INC	HL
	DJNZ	$30

	JP	FOUND

$40	; NO MATCH HERE - GO TO NEXT DIR ENTRY
	LD	HL,(DENTP)
	LD	DE,DENTSZ
	ADD	HL,DE
	LD	(DENTP),HL
	DEC	C
	JP	NZ,$20
;
;  WE DID NOT FIND THE INTERPETER IN THE DIRECTORY, SO PUT OUT AN ERROR MESSAGE
;  AND HANG.
;
	LD	HL,NOSYSMSG	; DISPLAY ERROR MESSAGE
	LD	BC,L_NSMSG
	MTRREQ	M_DSPTXT

$45	JR	$45		; HANG FOREVER


;*  	  READ IN INTERPRETER
;
FOUND	PROGRESS "D"
	LD	HL,INTERPORG	;READ INTERPRETER DIRECTLY TO ITS FINAL LOCATION
	LD	(DSKRQ+C_DRQADR),HL
	LD	IX,(DENTP)	; DIRECTORY ENTRY POINTER TO IX
	LD	L,(IX+DFIRSTBLK) ; BLOCK NUMBER TO HL
	LD	H,(IX+DFIRSTBLK+1)
	LD	(DSKRQ+C_DRQTRK),HL ; BLOCK NUMBER TO REQUEST BLOCK
	.IF	DEBUG
	LD	A,H
	CALL	HEXOUT
	LD	A,L
	CALL	HEXOUT
	.ENDC
	PUSH	HL		; MOVE STARTING BLOCK # TO DE
	POP	DE
	LD	L,(IX+DLASTBLK)	; LAST BLOCK + 1 TO HL
	LD	H,(IX+DLASTBLK+1)
	AND	A		; CLEAR CARRY FLAG
	SBC	HL,DE		; COMPUTE FILE LENGTH IN HL
	.IF	DEBUG
	LD	A,L
	CALL	HEXOUT
	.ENDC
	CALL	DSKRD		; READ MULTIPLE SECTORS
;
;  SET UP ENTRY CONDITIONS FOR INTERPRETER - TOP OF MEMORY IN HL,
;  BOOT UNIT NUMBER IN B - AND START IT.
;
	PROGRESS "E"
	LD	HL,(MEMTOP)	; TOP OF MEMORY
	LD	A,(DSKRQ+C_DRQUNT) ; BOOT UNIT NUMBER
	LD	B,A

	JP	INTERPORG+ENTRYPT ; JUMP TO INTEPRETER ENTRY POINT

	.PAGE

;*	  DSKRD - READ MULTIPLE DISK SECTORS
;
;  	ENTRY - DISK REQUEST BLOCK SET UP PROPERLY.
;               SECTOR COUNT IN HL.
;
;	EXIT - ALL REGISTERS USED.
;	       DOES NOT RETURN IF DISK ERROR ENCOUNTERED.
;
DSKRD	LD	(RDCNT),HL	; INITIALIZE SECTOR COUNT

$10	LD	HL,DSKRQ
	MTRREQ	M_DSKRD
	AND	A		; CHECK RETURN CODE
	JR	Z,$20		; IF NO ERROR

	JP 	DSKERR		; REPORT ERROR

$20	LD	HL,(DSKRQ+C_DRQADR) ; ADVANCE THE BUFFER ADDRESS
	.IF	DEBUG
	LD	A,(HL)
	CALL	HEXOUT
	.ENDC
	INC	H                   ; ASSUME SECTOR SIZE IS 512 BYTES
	INC	H
	LD	(DSKRQ+C_DRQADR),HL

	LD	HL,(RDCNT)	; DECREMENT THE SECTOR COUNT
	DEC	HL
	LD	(RDCNT),HL

	LD	A,H		; CHECK FOR ZERO
	OR	L
	JR	NZ,$10		; LOOP IF MORE SECTORS TO GO

	RET

	.PAGE
;*        SUBROUTINE SHOWPROG - DISPLAY A PROGRESS INDICATOR
;
;  OUTPUT A SINGLE CHARACTER, FOLLOWED BY <CR><LF>.
;
;         ENTRY - PARAMETER IN C REGISTER.
;
;         EXIT - ALL REGISTERS PRESERVED.
;
	.IF	DEBUG
SHOWPROG
        PUSH    IX              ; SAVE ALL USER REGISTERS
        PUSH    IY
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    AF

        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER
	LD	C,CH_CR
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER
	LD	C,CH_LF
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER

        MTRREQ	M_KBCHAR	; WAIT FOR USER

        POP     AF              ; RESTORE USER REGISTERS
        POP     BC
        POP     DE
        POP     HL
        POP     IY
        POP     IX

	RET
	.PAGE

;*        SUBROUTINE HEXOUT - WRITE OUT ONE BYTE IN HEX
;
;  TRANSLATE THE PARAMETER BYTE INTO TWO HEXIDECIMAL
;  CHARACTERS, AND WRITE THEM TO THE USER.
;
;         ENTRY - PARAMETER IN A REGISTER.
;
;         EXIT - A REGISTER DESTROYED.
;                ALL OTHERS PRESERVED.
;

HEXOUT
        PUSH    AF              ; SAVE PARAMETER FOR LATER
        SRL     A               ; RIGHT-JUSTIFY TOP DIGIT
        SRL     A
        SRL     A
        SRL     A
        CP      10.             ; IS IT NUMERIC
        JR      C,HEXOUTA       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTA
        ADD     A,"0"           ; MAKE INTO  ASCII
        CALL    OUTPUTCH        ; WRITE TOP NIBBLE

        POP     AF              ; GET BACK NUMBER
        AND     0FH             ; SAVE LOW DIGIT
        CP      10.             ; IT IS NUMERIC
        JR      C,HEXOUTB       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTB
        ADD     A,"0"           ; MAKE INTO ASCII
        CALL    OUTPUTCH        ; WRITE OUT BOTTOM DIGIT

        RET     	        ; AND  RETURN TO CALLER
        .PAGE
;*        SUBROUTINE TXTOUT - WRITE TEXT BLOCK TO USER
;
;  TRANSFER A TEXT STRING TERMINATED BY AN ETX CHARACTER TO
;  THE USER.
;
;         ENTRY - ADDRESS OF FIRST CHARACTER OF STRING IN HL
;
;         EXIT - HL POINTS TO ETX CHARACTER.
;                A CONTAINS -CH.ETX-
;                ALL OTHER REGISTERS ARE PRESERVED.
;
TXTOUT
        LD      A,(HL)          ; GET NEXT CHARACTER IN TEXT
        CP      CH_ETX          ; IS IT END-OF-TEXT
        RET     Z               ; RETURN IF IT IS END-OF-TEXT

        CALL    OUTPUTCH        ; WRITE OUT CHARACTER
        INC     HL              ; BUMP TEXT POINTER
        JR      TXTOUT          ; AND LOOP FOR NEXT CHARACTER
        .PAGE
;*        SUBROUTINE OUTPUTCH
;
;  WRITE ONE CHARACTER FROM REGISTER A TO THE
;  DISPLAY.
;
;         ENTRY - CHARACTER IN A
;
;         EXIT - ALL REGISTERS PRESERVED
;
OUTPUTCH
        PUSH    IX              ; SAVE ALL USER REGISTERS
        PUSH    IY
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    AF

        LD      C,A             ; MOVE CHARACTER TO C REGISTER
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER

        POP     AF              ; RESTORE USER REGISTERS
        POP     BC
        POP     DE
        POP     HL
        POP     IY
        POP     IX

        RET
	.ENDC
	.PAGE
;
;  GENERATE ERROR IF THIS IS TOO BIG TO FIT INTO TWO DISK SECTORS.
;
	.ORG	BOOTADR+L_BGSEC

	.END
